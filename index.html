<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Leon">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Leon">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leon">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Leon </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Leon</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/Http相关知识3/" itemprop="url">
                  Http相关知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-03T01:00:39+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络基础/" itemprop="url" rel="index">
                    <span itemprop="name">网络基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网络基础，大部分都参考自网上博客</p>
<h3 id="Http现状">Http现状</h3><h4 id="问题一：线头阻塞">问题一：线头阻塞</h4><p>线头阻塞是下一个HTTP请求要等待收到上一个请求的服务器的响应。为了解决这个便出现了HTTP管线化技术(HTTP Pipelining)。</p>
<p>HTTP Pipelining是把多个HTTP请求放到一个TCP连接中一一发送，不需要等待服务器的响应，客户端还是按发送的顺序接收响应。</p>
<ul>
<li>1.HTTP pipelining可以吧多个http请求输出到一个socket连接(倘若是基于socket的话，更确切的说应该是输出到一个传输层连接，在tcp ip中即为TCP连接)中去，然后等到对应的响应。只支持Http1.1以上，不支持1.0</li>
<li>2.线管化请求在页面加载方面有着很大的提升，特别是高延迟的连接</li>
<li>3.由于一个TCP包可以容纳几个HTTP请求, HTTP流水线传输的TCP数据包更少，减少网络负载。</li>
<li>4.只有幂等的请求（GET，HEAD, PUT, DELETE）能使用pipelining，非幂等请求比如POST不能使用，因为请求之间可能会存在先后依赖关系。</li>
<li><ol>
<li>绝大部分的http代理服务器不支持pipelining。</li>
</ol>
</li>
<li><ol>
<li>head of line blocking并没有完全得到解决，server的response还是要求依次返回，遵循FIFO(first in first out)原则。也就是说如果请求1的response没有回来，2，3，4，5的response也不会被送回来。<br><img src="http://chuantu.biz/t5/25/1470239678x1964742004.png" alt=""></li>
</ol>
</li>
</ul>
<h4 id="问题二：连接无法复用">问题二：连接无法复用</h4><p>http1.0协议头里可以设置Connection:Keep-Alive。在header里设置Keep-Alive可以在一定时间内复用连接，具体复用时间的长短可以由服务器控制，一般在15s左右。到http1.1之后Connection的默认值就是Keep-Alive，如果要关闭连接复用需要显式的设置Connection:Close。一段时间内的连接复用对PC端浏览器的体验帮助很大，因为大部分的请求在集中在一小段时间以内。但对移动app来说，成效不大，app端的请求比较分散且时间跨度相对较大。所以移动端app一般会从应用层寻求其它解决方案，基于tcp的长链接，http long-polling，http streaming， web socket</p>
<h3 id="Http_Content-Range">Http Content-Range</h3><p>Content-Range可以用来做获取文件的指定字节数<br>客户端请求报文：Range: bytes=200-299<br>服务器的响应报文会有下面这行：<br>HTTP/1.1 206 OK<br>Content-Range: bytes 200-299/403<br>206表示处理请求成功，<br>200-299指定的文件区间 403是总长度</p>
<h3 id="Http2-0">Http2.0</h3><p>Http2.0的目标是改善用户在使用web时的速度体验。</p>
<h4 id="Http2-0特点">Http2.0特点</h4><ul>
<li>多路复用 (Multiplexing)<br>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。<br><img src="http://chuantu.biz/t5/24/1470157184x1964742004.png" alt=""></li>
<li>新的二进制格式（Binary Format）<br>关键之一就是在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。<br><img src="http://chuantu.biz/t5/24/1470157077x1964742004.jpg" alt=""><br>HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。<br>在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。<br>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升</li>
<li>首部压缩（Header Compression）<br><img src="http://chuantu.biz/t5/24/1470157241x1964742004.png" alt=""></li>
<li>服务端推送（Server Push）http2.0能通过push的方式将客户端需要的内容预先推送过去，所以也叫“cache push”。<br><img src="http://chuantu.biz/t5/24/1470157282x1964742004.png" alt=""></li>
</ul>
<h3 id="Socket连接">Socket连接</h3><p>　常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的TCP服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的UDP服务应用。</p>
<h4 id="TCP_Socket连接">TCP Socket连接</h4><p>连接过程<br>1.创建客户端Socket<br>2.创建服务器Socket<br>3.连接到服务器(Socket编程)<br>4.发送数据给服务器<br>5.接收服务器返回的数据<br>6.关闭Socket : close(socketNumber)<br><img src="http://chuantu.biz/t5/24/1470152954x3738746571.jpg" alt="TCP Socket"></p>
<h4 id="UDP_Socket连接">UDP Socket连接</h4><p>连接过程<br>1.创建客户端Socket<br>2.创建服务器Socket<br>3.发送数据给服务器<br>4.服务器接收到请求，开始处理请求<br>5.服务器处理完成后应答数据<br>不需要创建连接和关闭连接<br><img src="http://chuantu.biz/t5/24/1470153016x3738746571.jpg" alt="UDP Socket"></p>
<h3 id="TCP和UDP">TCP和UDP</h3><p>传输层的核心协议是TCP和UDP。</p>
<h4 id="TCP:">TCP:</h4><ul>
<li>通信之前要建立连接，传输过程要保持连接，通信结束要关闭连接</li>
<li>按顺序接收</li>
<li>可靠服务<br>1.确认机制<br>2.超时重传机制</li>
<li>协议复杂效率比较低</li>
<li>只支持点对点传输</li>
<li>面向字节流。发送方的TCP将应用程序交下来的数据视为无结构字节流，并且分割成TCP报文段进行传输<br><img src="http://chuantu.biz/t5/24/1470152826x3738746571.png" alt="TCP报文"></li>
</ul>
<h4 id="UDP">UDP</h4><ul>
<li>通信不需要连接</li>
<li>顺序发送数据，但是未必顺序接收</li>
<li>不可靠服务</li>
<li>协议简单效率高</li>
<li>支持点到点和点到多点之间的通信</li>
<li>UDP适用于传输短的报文数据。最大64K</li>
<li>面向报文。发送方把应用程序发送的数据包装成UDP数据包，交付给网络层<br><img src="http://chuantu.biz/t5/24/1470152903x3738746571.png" alt="UDP报文"></li>
</ul>
<h3 id="ipv4和ipv6">ipv4和ipv6</h3><h4 id="什么是IPv4">什么是IPv4</h4><p>目前的全球因特网所采用的协议族是TCP/IP协议族。IP是TCP/IP协议族中网络层的协议，是TCP/IP协议族的核心协议。目前IP协议的版本号是4(简称为IPv4)，发展至今已经使用了30多年。<br>IPv4的地址位数为32位，也就是最多有2的32次方的电脑可以联到Internet上。<br>近十年来由于互联网的蓬勃发展，IP位址的需求量愈来愈大，使得IP位址的发放愈趋严格，各项资料显示全球IPv4位址可能在2005至2008年间全部发完。</p>
<h4 id="什么是IPv6">什么是IPv6</h4><p>IPv6是下一版本的互联网协议，也可以说是下一代互联网的协议，它的提出最初是因为随着互联网的迅速发展，IPv4定义的有限地址空间将被耗尽，地址空间的不足必将妨碍互联网的进一步发展。为了扩大地址空间，拟通过IPv6重新定义地址空间。IPv6采用128位地址长度，几乎可以不受限制地提供地址。按保守方法估算IPv6实际可分配的地址，整个地球的每平方米面积上仍可分配1000多个地址。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其它问题，主要有端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p>
<h4 id="IPv6与IPv4相比有什么特点和优点">IPv6与IPv4相比有什么特点和优点</h4><ul>
<li>更大的地址空间。IPv4中规定IP地址长度为32，即有2^32-1个地址；而IPv6中IP地址的长度为128，即有2^128-1个地址。</li>
<li>更小的路由表。IPv6的地址分配一开始就遵循聚类(Aggregation)的原则，这使得路由器能在路由表中用一条记录(Entry)表示一片子网，大大减小了路由器中路由表的长度，提高了路由器转发数据包的速度。</li>
<li>增强的组播(Multicast)支持以及对流的支持(Flow-control)。这使得网络上的多媒体应用有了长足发展的机会，为服务质量(QoS)控制提供了良好的网络平台.</li>
<li>加入了对自动配置(Auto-configuration)的支持。这是对DHCP协议的改进和扩展，使得网络(尤其是局域网)的管理更加方便和快捷.</li>
<li>更高的安全性.在使用IPv6网络中用户可以对网络层的数据进行加密并对IP报文进行校验,这极大的增强了网络安全. </li>
</ul>
<p><a href="http://www.jianshu.com/p/dc456cf57e06" target="_blank" rel="external">TCP/IP（四）：TCP 与 UDP 协议简介</a><br><a href="http://w3.pku.edu.cn/network/ipv6/ipv4-ipv6.htm" target="_blank" rel="external">IPv4和IPv6</a><br><a href="http://mrpeak.cn/blog/http2/" target="_blank" rel="external">HTTP 2.0的那些事</a><br><a href="http://www.zhihu.com/question/34074946" target="_blank" rel="external">HTTP/2.0 相比1.0有哪些重大改进</a><br><a href="https://www.gitbook.com/book/ye11ow/http2-explained/details" target="_blank" rel="external">http2讲解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/http基础知识2/" itemprop="url">
                  Http与Https连接
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T23:23:54+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络基础/" itemprop="url" rel="index">
                    <span itemprop="name">网络基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网络基础，大部分都参考自网上博客</p>
<p><img src="http://img.hoop8.com/1607D/fnZl16at.png" alt=""></p>
<h2 id="Http连接">Http连接</h2><h3 id="TCP工作原理">TCP工作原理</h3><p>http请求是基于TCP协议的<br>TCP的连接建立过程又称为TCP三次握手, 握手过程中使用TCP的标志flag,SYN (同步码)和 ACK(确认码)</p>
<ul>
<li>发送端首先发送一个SYN的数据包给对方。</li>
<li>接收端收到后，回传一个带有SYN/ACK标志的数据包以传达确认信息。</li>
<li>最后发送端再回传一个带有ACK标志的数据包，代表“握手”结束。</li>
<li>若在握手过程中中断了，TCP协议会再次以相同的顺序发送相同的数据包。<br>三次握手如下图<br><img src="http://chuantu.biz/t5/24/1470066394x3738746553.png" alt=""></li>
</ul>
<h2 id="Https连接">Https连接</h2><h3 id="Https介绍">Https介绍</h3><p>通常Http直接和TCP通信。当使用了SSL时，则演变成和SSL通信，再由SSL和TCP通信了。<br>Http +加密+认证+完整性保护= HTTPS 也就是说Http+SSL=HTTPS<br><img src="http://chuantu.biz/t5/24/1470066611x3738746541.png" alt=""></p>
<h3 id="Https连接-1">Https连接</h3><p>Https采用共享密钥加密和公开密钥两者加密并用的混合加密机制。</p>
<ul>
<li>共享密钥加密方式：<br>加密和解密共用一个密钥</li>
<li>公开密钥加密方式：<br>公开密钥使用一对非对称的密钥。一把私有密钥，一把公开密钥。发送方使用对方的公开密钥进行加密处理。对方<br>收到被加密的信息后，用自己的私钥进行解密。这样就不需要进行密钥传输了。</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a><br>SSL/TLS协议的基本过程是这样的：<br>（1） 客户端向服务器端索要并验证公钥。<br>（2） 双方协商生成”对话密钥”。<br>（3） 双方采用”对话密钥”进行加密通信。<br>上面过程的前两步，又称为”握手阶段”（handshake）。<br><img src="http://chuantu.biz/t5/24/1470067650x1964741964.png" alt="Https的安全通信进制"></p>
<h4 id="客户端发出请求">客户端发出请求</h4><p>客户端通过发送Client Hello 报文开始SSL通信。报文中包含<br>（1） 支持的协议版本，比如TLS 1.0版。<br>（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”，这个密码是明文的。<br>（3） 支持的加密方法，比如RSA公钥加密。<br>（4） 支持的压缩方法。</p>
<h4 id="服务器回应">服务器回应</h4><p>（1） 确认使用的加密通信协议版本，<br>（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”，这个密码是明文的。<br>（3） 确认使用的加密方法，比如RSA公钥加密。<br>（4） 服务器证书。</p>
<h4 id="客户端回应">客户端回应</h4><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。服务器可以用自己的私钥解开<br>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p>
<p>连接完成以后就用三个随机数构成的会话密钥进行对称加密的通信</p>
<h3 id="问题">问题</h3><ul>
<li>为什么使用三个随机数的原因？<br>这是由于SSL/TLS设计，就假设服务器不相信所有的客户端都能够提供完全随机数，假如某个客户端提供的随机数不随机的话，就大大增加了“对话密钥”被破解的风险，所以由三组随机数组成最后的随机数，保证了随机数的随机性，以此来保证每次生成的“对话密钥”安全性。</li>
<li>客户端验证数字证书的过程：<br><img src="http://chuantu.biz/t5/24/1470069954x1964741984.png" alt=""><br>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份后，会将已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起<br>服务器会将这份数字证书认证的公钥证书发送给客户端，以进行公开密钥加密方式通信。<br>接到证书的客户端可使用数字认证机构的公开密钥，对数字签名进行验证，验证通过则证明证书有效。<br>具体参考<br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a><br><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="external">iOS安全系列之一：HTTPS</a></li>
</ul>
<h2 id="Http与Https区别">Http与Https区别</h2><ul>
<li>Http优点：<br>1.简单快速:http协议简单,通信速度很快;<br>2.灵活:http协议允许传输任意类型的数据;<br>3.短连接:http协议限制每次连接只处理一个请求,服务器对客户端的请求作出响应后,马上断开连接.这种方式可以节省传输时间.</li>
<li>Http缺点:<br>1.通信使用明文不加密，内容可能会被窃听;<br>2.不验证通信方的身份，因此有可能遭遇伪装;<br>3.无法证明报文的完整性，所以可能被篡改;</li>
</ul>
<p>Https的优点就是安全，<br>缺点就是慢：1.通信慢 2.加密解密会消耗客户端和服务端的资源，使负载增加</p>
<h2 id="参考">参考</h2><p>图解http<br><a href="http://www.jianshu.com/p/cc756016243b" target="_blank" rel="external">深入浅出－iOS的TCP/IP协议族剖析&amp;&amp;Socket</a><br><a href="http://www.jianshu.com/p/13c09f4e6fac" target="_blank" rel="external">iOS开发探索-HTTP与HTTPS传输</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external">SSL/TLS协议运行机制的概述</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">图解SSL/TLS协议</a><br><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/" target="_blank" rel="external">iOS安全系列之一：HTTPS</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/31/Http基础知识1/" itemprop="url">
                  Http-网络基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-31T18:33:44+08:00" content="2016-07-31">
              2016-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/网络基础/" itemprop="url" rel="index">
                    <span itemprop="name">网络基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网络基础，大部分都参考自网上博客</p>
<h2 id="TCP/IP五层网络结构模型">TCP/IP五层网络结构模型</h2><h3 id="应用层">应用层</h3><p>应用层决定了向用户提供应用服务时通信的活动。<br>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。</p>
<h3 id="传输层">传输层</h3><p>负责主机中进程间的通信。在传输层有两个性质不同的协议：TCP和UDP</p>
<h3 id="网络层">网络层</h3><p>网络层用来处理在网络上的流动的数据包。数据包是网络传输的最小数据单元。该层规定了通过怎样的路径到达对方的计算机，并把数据包传给对方。网络层的作用在于选择一条传输线路</p>
<h3 id="数据链路层">数据链路层</h3><p>在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据的单位称为帧（frame）</p>
<h3 id="物理层">物理层</h3><p>物理层建立在物理通信介质的基础上，作为系统和通信介质的接口，用来实现数据链路实体间透明的比特 (bit) 流传输。只有该层为真实物理通信，其它各层为虚拟通信</p>
<p><img src="http://img.hoop8.com/1607D/fnZl16at.png" alt=""></p>
<h2 id="网络通信流程">网络通信流程</h2><p>举个例子说明一下，客户端发送一个http请求。<br><img src="http://img.hoop8.com/1607D/Da55tHhz.png" alt=""></p>
<p>通信路程如下图<br><img src="http://img.hoop8.com/1607D/qkoofTOn.png" alt=""></p>
<p>过程解析：</p>
<h3 id="DNS解析">DNS解析</h3><p>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。根据请求链接从DNS服务器查找到域名。</p>
<h3 id="应用层封装">应用层封装</h3><p>应用层把请求封装成http请求报文。HTTP部分的内容，类似于下面这样：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</div><div class="line">　　<span class="attribute">Host</span>: www.google.com</div><div class="line">　　<span class="attribute">Connection</span>: keep-alive</div><div class="line">　　<span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 6.1) ......</div><div class="line">　　<span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">　　<span class="attribute">Accept-Encoding</span>: gzip,deflate,sdch</div><div class="line">　　<span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.8</div><div class="line">　　<span class="attribute">Accept-Charset</span>: GBK,utf-8;q=0.7,*;q=0.3</div><div class="line">　　<span class="attribute">Cookie</span>: ... ...</div></pre></td></tr></table></figure>
<p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>
<h3 id="传输层建立”端口到端口”的通信">传输层建立”端口到端口”的通信</h3><p>传输层的UDP和TCP都使用了端口与上层应用程序进行通信，端口就是与应用程序的接口。不同的程序需要不同的端口。”端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p>TCP首部的源端口和目的端口包括源IP地址、源端口、目的IP地址、目的端口。<br>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。<br>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。<br>“传输层”的功能，就是建立”端口到端口”的通信。</p>
<h3 id="网络层建立”主机到主机”的通信">网络层建立”主机到主机”的通信</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。<br>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>
<h3 id="数据链路层-1">数据链路层</h3><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>
<p>所以，我们需要一种机制，能够从IP地址得到MAC地址。<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>
<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p>
<h2 id="参考">参考</h2><p>图解http<br><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="external">互联网协议入门（一）</a><br><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="external">互联网协议入门（二）</a> </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/09/音频处理Mp3/" itemprop="url">
                  音频处理-转MP3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-09T23:51:02+08:00" content="2016-03-09">
              2016-03-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/音频处理/" itemprop="url" rel="index">
                    <span itemprop="name">音频处理</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LAME是一个开源的MP3音频压缩软件。LAME是一个递归缩写，来自LAME Ain’t an MP3 Encoder（LAME不是MP3编码器）。它自1998年以来由一个开源社区开发，目前是公认有损品质MP3中压缩效果最好的编码器<br>这是支持arm64的<a href="https://github.com/wuqiong/mp3lame-for-iOS" target="_blank" rel="external">lame framework</a><br>也可以下载官方<a href="http://sourceforge.net/projects/lame/files/lame/3.99/" target="_blank" rel="external">lame3.99</a><br>然后根据这篇文章自行编译成静态库<a href="http://www.cocoachina.com/bbs/read.php?tid=108237" target="_blank" rel="external">lame的ios 静态库创建shell</a></p>
<h2 id="转化成MP3">转化成MP3</h2><p>录音设置参数<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define SampleRate 8000.0</span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSDictionary</span> *)recordSetting</div><div class="line">&#123;</div><div class="line">   <span class="built_in">NSDictionary</span> *recordSetting = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</div><div class="line">                                   [<span class="built_in">NSNumber</span> numberWithInt:<span class="built_in">AVAudioQualityHigh</span>],<span class="built_in">AVEncoderAudioQualityKey</span>,</div><div class="line">                                   [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">16</span>],<span class="built_in">AVEncoderBitRateKey</span>,</div><div class="line">                                   [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>],<span class="built_in">AVNumberOfChannelsKey</span>,</div><div class="line">                                   [<span class="built_in">NSNumber</span> numberWithFloat:SampleRate],<span class="built_in">AVSampleRateKey</span>,[<span class="built_in">NSNumber</span> numberWithInt:kAudioFormatLinearPCM],<span class="built_in">AVFormatIDKey</span>,</div><div class="line">                                   <span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> recordSetting;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PCM转换成MP3格式<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)tranformPCMToMP3</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *cafFilePath = [<span class="keyword">self</span> pcmPath];</div><div class="line">    <span class="built_in">NSString</span> *mp3FilePath = [<span class="keyword">self</span> mp3Path];</div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    [fileManager removeItemAtPath:mp3FilePath error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">@try</span> &#123;</div><div class="line">        <span class="keyword">int</span> read, write;</div><div class="line">        FILE *pcm = fopen([cafFilePath cStringUsingEncoding:<span class="number">1</span>], <span class="string">"rb"</span>);  <span class="comment">//source 被转换的音频文件位置</span></div><div class="line">        fseek(pcm, <span class="number">4</span>*<span class="number">1024</span>, SEEK_CUR);                                   <span class="comment">//skip file header</span></div><div class="line">        FILE *mp3 = fopen([mp3FilePath cStringUsingEncoding:<span class="number">1</span>], <span class="string">"wb"</span>);  <span class="comment">//output 输出生成的Mp3文件位置</span></div><div class="line">        </div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> PCM_SIZE = <span class="number">8192</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">MP3_SIZE</span> = <span class="number">8192</span>;</div><div class="line">        <span class="keyword">short</span> <span class="keyword">int</span> pcm_buffer[PCM_SIZE*<span class="number">2</span>];</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> mp3_buffer[<span class="built_in">MP3_SIZE</span>];</div><div class="line">        </div><div class="line">        lame_t lame = lame_init();</div><div class="line">        lame_set_num_channels(lame, <span class="number">2</span>);</div><div class="line">        lame_set_brate(lame, <span class="number">16</span>);</div><div class="line">        lame_set_mode(lame, <span class="number">3</span>);</div><div class="line">        lame_set_quality(lame, <span class="number">2</span>);</div><div class="line">        lame_set_in_samplerate(lame, SampleRate);</div><div class="line"><span class="comment">//        lame_set_VBR(lame, vbr_default);</span></div><div class="line">        lame_init_params(lame);</div><div class="line">        </div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            read = fread(pcm_buffer, <span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>), PCM_SIZE, pcm);</div><div class="line">            <span class="keyword">if</span> (read == <span class="number">0</span>)</div><div class="line">                write = lame_encode_flush(lame, mp3_buffer, <span class="built_in">MP3_SIZE</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, <span class="built_in">MP3_SIZE</span>);</div><div class="line">            </div><div class="line">            fwrite(mp3_buffer, write, <span class="number">1</span>, mp3);</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">while</span> (read != <span class="number">0</span>);</div><div class="line">        </div><div class="line">        lame_close(lame);</div><div class="line">        fclose(mp3);</div><div class="line">        fclose(pcm);</div><div class="line">        </div><div class="line"><span class="comment">//        [fileManager removeItemAtPath:cafFilePath error:nil];</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[exception description]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里需要说明，这些参数要对应不然会失真，或者时间长度不对</p>
<table>
<thead>
<tr>
<th>recordSetting</th>
<th>Lame</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVEncoderAudioQualityKey</td>
<td>lame_set_quality(lame, 2)</td>
</tr>
<tr>
<td>AVEncoderBitRateKey</td>
<td>lame_set_brate(lame, 16)</td>
</tr>
<tr>
<td>AVNumberOfChannelsKey</td>
<td>lame_set_num_channels(lame, 2)</td>
</tr>
<tr>
<td>AVSampleRateKey</td>
<td>lame_set_in_samplerate(lame, SampleRate)</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/Hello!/" itemprop="url">
                  随想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T01:18:47+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/思考人生/" itemprop="url" rel="index">
                    <span itemprop="name">思考人生</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一转眼2015年已不足百日。Never Too Late！！！以后要坚持每天来写点东西</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/NSURLProtocol/" itemprop="url">
                  NSURLProtocol
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T01:18:47+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Foundation/" itemprop="url" rel="index">
                    <span itemprop="name">Foundation</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSURLProtocol</p>
<h2 id="前言">前言</h2><p>翻译自<a href="http://www.raywenderlich.com/59982/nsurlprotocol-tutorial" target="_blank" rel="external">http://www.raywenderlich.com/59982/nsurlprotocol-tutorial</a><br>NSURLProtocol也是苹果众多黑魔法中的一种，使用它可以轻松地重定义整个URL Loading System。当你注册自定义NSURLProtocol后，就有机会对所有的请求进行统一的处理.<br>这个教程中我们可以学到如何定义一个协议处理器来修改URL schemes.它将添加一个缓存层，通过Core Data来存储可恢复的数据。启用它一个普通的浏览器就能缓存网页，可供离线使用。<br>在学这个教程之前我们需要先知道一些网络基础和NSURLConnection怎么工作的。<br><a href="http://www.raywenderlich.com/?p=51127" target="_blank" rel="external">网络基础</a><br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLConnection.html" target="_blank" rel="external">官方文档</a></p>
<h2 id="What_Is_NSURLProtocol?">What Is NSURLProtocol?</h2><p>我们得知道URL Loading System才能发现iOS系统是怎么处理app的URL请求.URL Loading System包括了NSURL，NSURLRequest，NSURLConnection或是NSURLSession。<br>当你接收到响应后，你讲收到metadata 和 data.NSURLResponse封装了metadata。metadata里面将告诉我们MIME文本编码类型，可能接收到的数据的长度。NSURLRequest会创建一个NSURLProtocol的子类，这就是你自定义的Protocol。注意不要去直接初始化NSURLProtocol。这个名字听起来很像个协议，但却是个类</p>
<h2 id="When_To_Use_NSURLProtocol?">When To Use NSURLProtocol?</h2><p>怎么使用NSURLProtocol让你的app变得更快更好？<br>1.Provide Custom Responses For Your Network Requests:<br>为你的请求提供自定义的响应<br>2.Skip Network Activity and Provide Local Data:<br>跳过网络请求，提供本地数据<br>3.Redirect Your Network Requests:<br>重定向网络请求<br>4.Change the User-agent of Your Requests:<br>改变你的用户代理请求<br>5.Use Your Own Networking Protocol:<br>使用自己的网络协议</p>
<h2 id="Getting_Started">Getting Started</h2><p>我们要做的app是一个有缓存功能的例子，做完这个例子我们就知道怎么使用NSURLProtocol处理网络请求。<br><a href="http://cdn3.raywenderlich.com/wp-content/uploads/2013/12/NSURLProtocolExample.zip" target="_blank" rel="external">Start Project</a><br>这里还要提醒一下在info.plist里面<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>打开项目,打开Main.storyboard我们可以看到一个UIWebView，UITextFiled，UIButton<br>打开BrowserViewController.m. 输入网站，点击sendRequest发出网络请求</p>
<h2 id="Intercepting_network_requests">Intercepting network requests</h2><p>现在开始截取NSURLRequest请求。创建NSURLProtocol，点击 File\New\File…. 选择 Objective-C class 点击 Next 按钮. 输入 MyURLProtocol subclass那边选择 NSURLProtocol. 打开MyURLProtocol<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSUInteger</span> requestCount = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Request #%u: URL = %@"</span>, requestCount++, request.URL.absoluteString);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每次请求都会调用+canInitWithRequest方法 通过return YES或者NO来决定是否摇出来这个请求<br>还有一步不要忘了在Appdelegate.m中注册NSURLProtocol<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    [<span class="built_in">NSURLProtocol</span> registerClass:[MyURLProtocol <span class="keyword">class</span>]];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输入网址就可以开始截取请求了</p>
<h2 id="Custom_URL_Loading">Custom URL Loading</h2><p>每个NSURLProtocol都有个NSURLProtocolClient，通过这client你可以传回数据<br>打开MyURLProtocol.m添加<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> MyURLProtocol () &lt;NSURLConnectionDelegate&gt;</div><div class="line"><span class="variable">@property</span> (nonatomic, strong) NSURLConnection *connection;</div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)<span class="string">canInitWithRequest:</span>(NSURLRequest *)request &#123;</div><div class="line">    <span class="keyword">static</span> NSUInteger requestCount = <span class="number">0</span>;</div><div class="line">    NSLog(@<span class="string">'Request #%u: URL = %@'</span>, requestCount++, request.URL.absoluteString);</div><div class="line">    <span class="keyword">return</span> YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSURLRequest *)<span class="string">canonicalRequestForRequest:</span>(NSURLRequest *)request &#123;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)<span class="string">requestIsCacheEquivalent:</span>(NSURLRequest *)a <span class="string">toRequest:</span>(NSURLRequest *)b &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">requestIsCacheEquivalent:</span>a <span class="string">toRequest:</span>b];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startLoading &#123;</div><div class="line">    self.connection = [NSURLConnection <span class="string">connectionWithRequest:</span>self.request <span class="string">delegate:</span>self];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopLoading &#123;</div><div class="line">    [self.connection cancel];</div><div class="line">    self.connection = nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>+canonicalRequestForRequest:这个方法是NSURLProtocol必须实现的方法。在这个方法中我们至少需要返回一个request。<br>在这个方法里面，你可以直接返回request你也可以对request请求进行修改增加头部返回请的请求。</p>
<p>+requestIsCacheEquivalent:toRequest: 用于判断你的自定义reqeust是否相同，这里返回默认实现即可。它的主要应用场景是某些直接使用缓存而非再次请求网络的地方。</p>
<p>-startLoading  -stopLoading实现请求和取消流程。</p>
<p>打开MyURLProtocol.m<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">connection</span><span class="selector-pseudo">:(NSURLConnection</span> *)<span class="selector-tag">connection</span> <span class="selector-tag">didReceiveResponse</span><span class="selector-pseudo">:(NSURLResponse</span> *)<span class="selector-tag">response</span> &#123;</div><div class="line">    <span class="selector-attr">[self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">connection</span><span class="selector-pseudo">:(NSURLConnection</span> *)<span class="selector-tag">connection</span> <span class="selector-tag">didReceiveData</span><span class="selector-pseudo">:(NSData</span> *)<span class="selector-tag">data</span> &#123;</div><div class="line">    <span class="selector-attr">[self.client URLProtocol:self didLoadData:data]</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">connectionDidFinishLoading</span><span class="selector-pseudo">:(NSURLConnection</span> *)<span class="selector-tag">connection</span> &#123;</div><div class="line">    <span class="selector-attr">[self.client URLProtocolDidFinishLoading:self]</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">connection</span><span class="selector-pseudo">:(NSURLConnection</span> *)<span class="selector-tag">connection</span> <span class="selector-tag">didFailWithError</span><span class="selector-pseudo">:(NSError</span> *)<span class="selector-tag">error</span> &#123;</div><div class="line">    <span class="selector-attr">[self.client URLProtocol:self didFailWithError:error]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这几个NSURLConnection的协议大家都很熟悉，在这些协议中收到请求后通过client进行转发</p>
<h2 id="Squashing_the_Infinite_Loop_with_Tag">Squashing the Infinite Loop with Tag</h2><p>为什么会出现无限循环呢。<br>当UIWebView发起请求，在 +canInitWithRequest:判断是否能发起请求，如果能的话就开始-startLoading。这个方法里面又有个请求，又会回到 +canInitWithRequest:一直循环下去。那我们该怎么解决这个问题呢？<br>可以通过+setProperty:forKey:inRequest:标示那些已经处理过的request，然后在+canInitWithRequest:中查询该request是否已经处理过了，如果是则返回NO。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSUInteger</span> requestCount = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Request #%u: URL = %@"</span>, requestCount++, request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:<span class="string">@"MyURLProtocolHandledKey"</span> inRequest:request]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startLoading &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *newRequest = [<span class="keyword">self</span>.request mutableCopy];</div><div class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:<span class="string">@"MyURLProtocolHandledKey"</span> inRequest:newRequest];</div><div class="line">    <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:newRequest delegate:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就好了，下一步就开始缓存数据</p>
<h2 id="Implementing_the_Local_Cache">Implementing the Local Cache</h2><p>接下来我们用coreData来做数据缓存。打开NSURLProtocolExample.xcdatamodeld<br>修改Entity为CachedURLResponse增加Attribute<br>点击File\New\File 在点击Core Data\NSManagedObject创建CachedURLResponse<br><img src="http://i11.tietuku.com/5d0c402e200efb18.png" alt=""><br>打开MyURLProtocol.h 添加属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableData</span> *mutableData;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLResponse</span> *response;</div></pre></td></tr></table></figure></p>
<p>修改以下协议<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</div><div class="line">    <span class="keyword">self</span>.response = response;</div><div class="line">    <span class="keyword">self</span>.mutableData = [[<span class="built_in">NSMutableData</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</div><div class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</div><div class="line">    [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</div><div class="line">    [<span class="keyword">self</span> saveCachedResponse];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#import AppDelegate.h和CachedURLResponse.h文件添加保存方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)saveCachedResponse &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"saving cached response"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 1.</span></div><div class="line">    AppDelegate *delegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = delegate.managedObjectContext;</div><div class="line"></div><div class="line">    <span class="comment">// 2.</span></div><div class="line">    CachedURLResponse *cachedResponse = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"CachedURLResponse"</span></div><div class="line">    inManagedObjectContext:context];</div><div class="line">    cachedResponse.data = <span class="keyword">self</span>.mutableData;</div><div class="line">    cachedResponse.url = <span class="keyword">self</span>.request.URL.absoluteString;</div><div class="line">    cachedResponse.timestamp = [<span class="built_in">NSDate</span> date];</div><div class="line">    cachedResponse.mimeType = <span class="keyword">self</span>.response.MIMEType;</div><div class="line">    cachedResponse.encoding = <span class="keyword">self</span>.response.textEncodingName;</div><div class="line"></div><div class="line">    <span class="comment">// 3.</span></div><div class="line">    <span class="built_in">NSError</span> *error;</div><div class="line">    <span class="built_in">BOOL</span> <span class="keyword">const</span> success = [context save:&amp;error];</div><div class="line">    <span class="keyword">if</span> (!success) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Could not cache the response."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Retrieving_the_Cached_Response">Retrieving the Cached Response</h2><p>最后一步我们来恢复刚才保存的数据<br>打开MyURLProtocol.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">- (CachedURLResponse *)cachedResponseForCurrentRequest &#123;</div><div class="line">    <span class="comment">// 1.</span></div><div class="line">    AppDelegate *delegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = delegate.managedObjectContext;</div><div class="line"></div><div class="line">    <span class="comment">// 2.</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *fetchRequest = [[<span class="built_in">NSFetchRequest</span> alloc] init];</div><div class="line">    <span class="built_in">NSEntityDescription</span> *entity = [<span class="built_in">NSEntityDescription</span> entityForName:<span class="string">@"CachedURLResponse"</span></div><div class="line">    inManagedObjectContext:context];</div><div class="line">    [fetchRequest setEntity:entity];</div><div class="line"></div><div class="line">    <span class="comment">// 3.</span></div><div class="line">    <span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"url == %@"</span>, <span class="keyword">self</span>.request.URL.absoluteString];</div><div class="line">    [fetchRequest setPredicate:predicate];</div><div class="line"></div><div class="line">    <span class="comment">// 4.</span></div><div class="line">    <span class="built_in">NSError</span> *error;</div><div class="line">    <span class="built_in">NSArray</span> *result = [context executeFetchRequest:fetchRequest error:&amp;error];</div><div class="line"></div><div class="line">    <span class="comment">// 5.</span></div><div class="line">    <span class="keyword">if</span> (result &amp;&amp; result.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> result[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startLoading &#123;</div><div class="line"><span class="comment">// 1.</span></div><div class="line">    CachedURLResponse *cachedResponse = [<span class="keyword">self</span> cachedResponseForCurrentRequest];</div><div class="line">    <span class="keyword">if</span> (cachedResponse) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"serving response from cache"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 2.</span></div><div class="line">        <span class="built_in">NSData</span> *data = cachedResponse.data;</div><div class="line">        <span class="built_in">NSString</span> *mimeType = cachedResponse.mimeType;</div><div class="line">        <span class="built_in">NSString</span> *encoding = cachedResponse.encoding;</div><div class="line"></div><div class="line">        <span class="comment">// 3.</span></div><div class="line">        <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:<span class="keyword">self</span>.request.URL</div><div class="line">        MIMEType:mimeType</div><div class="line">        expectedContentLength:data.length</div><div class="line">        textEncodingName:encoding];</div><div class="line"></div><div class="line">        <span class="comment">// 4.</span></div><div class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didReceiveResponse:response cacheStoragePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span>];</div><div class="line">        [<span class="keyword">self</span>.client URLProtocol:<span class="keyword">self</span> didLoadData:data];</div><div class="line">        [<span class="keyword">self</span>.client URLProtocolDidFinishLoading:<span class="keyword">self</span>];</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 5.</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"serving response from NSURLConnection"</span>);</div><div class="line"></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *newRequest = [<span class="keyword">self</span>.request mutableCopy];</div><div class="line">        [<span class="built_in">NSURLProtocol</span> setProperty:@YES forKey:<span class="string">@"MyURLProtocolHandledKey"</span> inRequest:newRequest];</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:newRequest delegate:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1.我们先查找当前请求有没有本地缓存响应<br>2.把相关数据取出<br>3.创建一个NSURLResponse<br>4.传入NSURLCacheStorageNotAllowed的原因是我们自己控制缓存，接下来我们就可以通过client将response发出去<br>5.如果没有缓存就正常加载</p>
<h2 id="总结">总结</h2><p><a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/12/NSURLProtocolExample1.zip" target="_blank" rel="external">Finished Project</a></p>
<h3 id="附加1">附加1</h3><p>重定向到github<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSURLRequest</span> *) canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [request mutableCopy];</div><div class="line">    mutableReqeust = [<span class="keyword">self</span> redirectHostInRequset:mutableReqeust];</div><div class="line">    <span class="keyword">return</span> mutableReqeust;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+(<span class="built_in">NSMutableURLRequest</span>*)redirectHostInRequset:(<span class="built_in">NSMutableURLRequest</span>*)request</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([request.URL host].length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *originUrlString = [request.URL absoluteString];</div><div class="line">    <span class="built_in">NSString</span> *originHostString = [request.URL host];</div><div class="line">    <span class="built_in">NSRange</span> hostRange = [originUrlString rangeOfString:originHostString];</div><div class="line">    <span class="keyword">if</span> (hostRange.location == <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        <span class="keyword">return</span> request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//定向到github主页</span></div><div class="line">    <span class="built_in">NSString</span> *ip = <span class="string">@"github.com"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 替换域名</span></div><div class="line">    <span class="built_in">NSString</span> *urlString = [originUrlString stringByReplacingCharactersInRange:hostRange withString:ip];</div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</div><div class="line">    request.URL = url;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="附加2">附加2</h3><p>没有实现足够的回调方法导致各种奇葩问题。如connection:willSendRequest:redirectResponse: 内如果没有通过[self client]回传消息，那么需要重定向的网页就会出现问题:host不对或者造成跨域调用导致资源无法加载。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/CoreAnimation/" itemprop="url">
                  CoreAnimation的一些注意点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T01:18:47+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/CoreAnimation/" itemprop="url" rel="index">
                    <span itemprop="name">CoreAnimation</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题">问题</h2><p>前不久做一个社交应用地图上有个脉冲波式的效果像这样<br><img src="https://github.com/shu223/PulsingHalo/blob/master/demo_.gif?raw=true" alt=""><br>做完打算收工时，不小心点了一下home键，又不小心重新进入app，悲剧发生了动画没了。<br>这里介绍三种处理方式</p>
<h2 id="第一种">第一种</h2><p>简单粗暴直接重新添加</p>
<pre><code>[view.layer <span class="string">addAnimation:</span>rotation <span class="string">forKey:</span>@<span class="string">"rotationAnimation"</span>];
</code></pre><h2 id="第二种">第二种</h2><p>根据Technical Q&amp;A QA1673<br><a href="https://developer.apple.com/library/ios/qa/qa1673/_index.html" target="_blank" rel="external">How to pause the animation of a layer tree</a></p>
<pre><code>-(<span class="keyword">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer
{
    <span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];
    layer<span class="variable">.speed</span> = <span class="number">0.0</span>;
    layer<span class="variable">.timeOffset</span> = pausedTime;
}

-(<span class="keyword">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer
{
    <span class="built_in">CFTimeInterval</span> pausedTime = [layer timeOffset];
    layer<span class="variable">.speed</span> = <span class="number">1.0</span>;
    layer<span class="variable">.timeOffset</span> = <span class="number">0.0</span>;
    layer<span class="variable">.beginTime</span> = <span class="number">0.0</span>;
    <span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;
    layer<span class="variable">.beginTime</span> = timeSincePause;
}
</code></pre><p>监听一下<br>UIKIT_EXTERN NSString <em>const UIApplicationDidEnterBackgroundNotification       NS_AVAILABLE_IOS(4_0);<br>UIKIT_EXTERN NSString </em>const UIApplicationWillEnterForegroundNotification<br>然后在</p>
<pre><code><span class="tag">-</span> (void)<span class="tag">applicationWillEnterForeground</span>:(UIApplication *)<span class="tag">application</span>
{
    <span class="attr_selector">[self pauseLayer:layer]</span>;
}
<span class="tag">-</span> (void)<span class="tag">applicationDidEnterBackground</span>:(UIApplication *)<span class="tag">application</span>
{
    <span class="attr_selector">[self resumeLayer:layer]</span>;
}
</code></pre><h2 id="第三种">第三种</h2><p>直接设置removedOnCompletion = NO;<br>这种方法对于不会停止的动画还是很有用的</p>
<h2 id="其他">其他</h2><p>对于UIView animation 照样有影响 你会看到动画直接走到结束 直接就调用finished里面的block，所以可能要注意一下</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/Search API/" itemprop="url">
                  Search API
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T01:18:47+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS9/" itemprop="url" rel="index">
                    <span itemprop="name">iOS9</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近几年苹果推出了一系列的搜索框架NSUserActivity,Web Markup,Core Spotlight今天我们来学习一下NSUserActivity,Core Spotlight<br>参考自<a href="http://www.appcoda.com.tw/search-api-sfsafariviewcontroller/" target="_blank" rel="external">http://www.appcoda.com.tw/search-api-sfsafariviewcontroller/</a></p>
<h2 id="简介">简介</h2><p>iOS 9 SDK 中新的搜索 API 包含下列 3 個主要元件：<br>1.NSUserActivity ，可以建立关键字及其他內容的索引<br>2.Web Markup ，针对 Spotlight 优化建立网络索引，支持 App 的「深度链接」（ Deep Linking ）和通用链接（ Universal Link ）。<br>3.Core Spotlight ，可以针对 App 的所有內容建立深度链接。</p>
<h2 id="NSUserActivity">NSUserActivity</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserActivity</span> *myActivity = [[<span class="built_in">NSUserActivity</span> alloc] initWithActivityType:<span class="string">@"com.17youkong.SearchAPI"</span>];</div><div class="line">myActivity.title = <span class="string">@"SearchAPI"</span>;</div><div class="line">myActivity.eligibleForSearch = <span class="literal">YES</span>;</div><div class="line"><span class="comment">// 设置搜索内容</span></div><div class="line">myActivity.keywords = [<span class="built_in">NSSet</span> setWithArray:@[<span class="string">@"111"</span>, <span class="string">@"222"</span>, <span class="string">@"333"</span>, <span class="string">@"444"</span>]];</div><div class="line">[myActivity becomeCurrent];</div><div class="line"><span class="keyword">self</span>.userActivity = myActivity;<span class="comment">// 这句话很重要</span></div><div class="line"></div><div class="line"><span class="comment">// 如果你想根据搜索内容做点什么的话</span></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="keyword">nonnull</span> <span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="keyword">nonnull</span> <span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">nonnull</span> <span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> * __<span class="keyword">nullable</span>))restorationHandler&#123;</div><div class="line">    <span class="built_in">NSString</span> *idetifier = userActivity.userInfo[<span class="string">@"kCSSearchableItemActivityIdentifier"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://chuantu.biz/t2/20/1448818152x1822611380.png" alt=""></p>
<h2 id="CoreSpotlight">CoreSpotlight</h2><p>参考自<a href="http://blog.csdn.net/mengxiangyue/article/details/46585159" target="_blank" rel="external">http://blog.csdn.net/mengxiangyue/article/details/46585159</a><br><img src="http://img.blog.csdn.net/20150621231031937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWVuZ3hpYW5neXVl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>对于CoreSpotlight可以类比NSUserDefault，都是全局的存储空间。不同的是CoreSpotlight是系统的存储空间，每个App都能访问（可能这个访问有限制，目前还没有时间研究），但是NSUserDefault是每个App私有的。另外对于存储的内容CoreSpotlight存储的是item，即CSSearchableItem，而每个CSSearchableItem又有许多属性，这些属性是通过CSSearchableItemAttributeSet进行设置。具体都有神马属性，大家自己去看头文件吧。</p>
<p>下面写一下简单得步骤：</p>
<p>1 引入CoreSpotlight.framework</p>
<p>2 创建CSSearchableItemAttributeSet、CSSearchableItem</p>
<p>3 调用CSSearchableIndex.defaultSearchableIndex()的相关的方法对item进行操作。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CSSearchableItemAttributeSet *<span class="keyword">set</span> = [[CSSearchableItemAttributeSet <span class="comment">alloc] initWithItemContentType:@</span><span class="comment">"com.17youkong.SearchAPI"</span><span class="comment">]</span>;</div><div class="line"><span class="keyword">set</span>.title <span class="comment">= @</span><span class="comment">"1111"</span>;</div><div class="line"><span class="keyword">set</span>.contentDescription <span class="comment">= [NSString stringWithFormat:@</span><span class="comment">"a easy way to open"</span><span class="comment">]</span>;</div><div class="line">UIImage *thumbImage = [UIImage imageNamed:[NSString stringWithFormat:@<span class="string">"icon.png"</span>]];</div><div class="line"><span class="keyword">set</span>.thumbnailData <span class="comment">= UIImagePNGRepresentation(thumbImage)</span>;<span class="comment">//beta 1 there is a bug</span></div><div class="line">CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:@<span class="string">"111"</span>                                                                                                                                    domainIdentifier:@<span class="string">"com.kdanmobile.CoreSpotlightDemo"</span>                                                                                                        attributeSet:<span class="keyword">set</span>];</div><div class="line">[[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:@[item] completionHandler:^(NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">&#125;];</div><div class="line">![](http:<span class="comment">//i12.tietuku.com/9f47c7e0d17cd1a9.png)</span></div></pre></td></tr></table></figure>
<p>最后需要提到的就是索引的删除。CoreSpotlight给我们提供了三个方法来进行删除分别是：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deleteSearchableItemsWithIdentifiers:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)identifiers completionHandler:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="built_in">NSError</span> * __<span class="keyword">nullable</span> error))completionHandler; </div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)deleteSearchableItemsWithDomainIdentifiers:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)domainIdentifiers completionHandler:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="built_in">NSError</span> * __<span class="keyword">nullable</span> error))completionHandler;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)deleteAllSearchableItemsWithCompletionHandler:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="built_in">NSError</span> * __<span class="keyword">nullable</span> error))completionHandler;</div></pre></td></tr></table></figure></p>
<p>根据identifier来删除，根据domain来删除以及删除所有的索引。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/UIPopoverPresentationController/" itemprop="url">
                  UIPopoverPresentationController
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T01:18:47+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS8/" itemprop="url" rel="index">
                    <span itemprop="name">iOS8</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UIPopoverPresentationController是提供高级视图切换的类。它让管理present ViewController的过程变得简单。<br>先讲一些presentation基础知识，在iPad的设置页面，可以通过popOver弹出一个UIViewController，这个弹出的，可以和用户交互的Controller叫做PresentedViewController，而后面那个被部分遮挡的UIViewController叫做PresentingViewController<br>接下来我们就一步步的看UIPopoverPresentationController该如何使用</p>
<h2 id="创建项目">创建项目</h2><p>创建ViewController 创建一个按钮 点击弹出列表页<br>创建ListTableVC 列表页</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)presentAction:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    <span class="keyword">self</span>.vc = [[ListTableVC alloc] init];</div><div class="line">    <span class="keyword">self</span>.vc.modalPresentationStyle = <span class="built_in">UIModalPresentationPopover</span>;</div><div class="line">    <span class="keyword">self</span>.vc.popoverPresentationController.sourceView = sender;</div><div class="line">    <span class="keyword">self</span>.vc.popoverPresentationController.sourceRect = sender.bounds;</div><div class="line">    <span class="keyword">self</span>.vc.popoverPresentationController.permittedArrowDirections = <span class="built_in">UIPopoverArrowDirectionAny</span>;</div><div class="line">    <span class="keyword">self</span>.vc.preferredContentSize = <span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line">    [<span class="keyword">self</span> presentViewController:<span class="keyword">self</span>.vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好像设置这些属性没用怎么回事，为什么还是全屏的<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.vc.modalPresentationStyle = <span class="built_in">UIModalPresentationPopover</span>;</div><div class="line"><span class="keyword">self</span>.vc.popoverPresentationController.sourceView = sender;</div><div class="line"><span class="keyword">self</span>.vc.popoverPresentationController.sourceRect = sender.bounds;</div><div class="line"><span class="keyword">self</span>.vc.popoverPresentationController.permittedArrowDirections = <span class="built_in">UIPopoverArrowDirectionAny</span>;</div><div class="line"><span class="keyword">self</span>.vc.preferredContentSize = <span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="UIPopoverPresentationControllerDelegate">UIPopoverPresentationControllerDelegate</h2><p>看看源文件里面有个UIPopoverPresentationControllerDelegate<uiadaptivepresentationcontrollerdelegate><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* For iOS8.0, the only supported adaptive presentation styles are UIModalPresentationFullScreen and UIModalPresentationOverFullScreen. */</span></div><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)adaptivePresentationStyleForPresentationController:(<span class="built_in">UIPresentationController</span> *)controller;</div><div class="line"></div><div class="line"><span class="comment">// Returning UIModalPresentationNone will indicate that an adaptation should not happen.</span></div><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)adaptivePresentationStyleForPresentationController:(<span class="built_in">UIPresentationController</span> *)controller traitCollection:(<span class="built_in">UITraitCollection</span> *)traitCollection <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_3);</div></pre></td></tr></table></figure></uiadaptivepresentationcontrollerdelegate></p>
<p>adaptive 试试看<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">UIPopoverPresentationControllerDelegate</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">IBAction</span>)presentAction:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    <span class="keyword">self</span>.vc = [[ListTableVC alloc] init];</div><div class="line">    <span class="keyword">self</span>.vc.modalPresentationStyle = <span class="built_in">UIModalPresentationPopover</span>;</div><div class="line">    <span class="keyword">self</span>.vc.popoverPresentationController.sourceView = sender;</div><div class="line">    <span class="keyword">self</span>.vc.popoverPresentationController.sourceRect = sender.bounds;</div><div class="line">    <span class="keyword">self</span>.vc.popoverPresentationController.permittedArrowDirections = <span class="built_in">UIPopoverArrowDirectionAny</span>;</div><div class="line">    <span class="comment">//    self.vc.popoverPresentationController.delegate = self;</span></div><div class="line">    <span class="keyword">self</span>.vc.preferredContentSize = <span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line">    [<span class="keyword">self</span> presentViewController:<span class="keyword">self</span>.vc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)adaptivePresentationStyleForPresentationController:(<span class="built_in">UIPresentationController</span> *)controller&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIModalPresentationNone</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>run<br><img src="http://i5.tietuku.com/16acb05d08a0c9bb.png" alt=""></p>
<h2 id="DismissPopover">DismissPopover</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)popoverPresentationControllerShouldDismissPopover:(<span class="built_in">UIPopoverPresentationController</span> *)popoverPresentationController&#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;   <span class="comment">//点击蒙版popover不消失， 默认yes</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/WatchOS/" itemprop="url">
                  WatchOS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-12T01:18:47+08:00" content="2015-11-12">
              2015-11-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/WatchOS/" itemprop="url" rel="index">
                    <span itemprop="name">WatchOS</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>WatchOS 如何和配对物交流数据。自从watchOS出来以后大家都在找寻找一种2者之间数据互通的方法<br>今天介绍一下简单的连接框架 Watch Connectivity framework<br>翻译自<a href="http://code.tutsplus.com/tutorials/ios-9-an-introduction-to-3d-touch--cms-25115" target="_blank" rel="external">http://code.tutsplus.com/tutorials/ios-9-an-introduction-to-3d-touch--cms-25115</a></p>
<h2 id="前言">前言</h2><p>Watch Connectivity<br>connectivity可以做很多事情 发送消息 ，转换数据，甚至还可以转化文件夹<br>我建议你先看看 Apple’s documentation<br>这个教程将教你如何在watchOS和 iOS设备之间如何传递数据。我们将使用的API是sendMessage(<em>:replyHandler:errorHandler:)<br>有一点重要的细节需要注意<br>iOS设备和Watch在接收到sendMessage(</em>:replyHandler:errorHandler:) 表现得不一样<br>iOS设备将被系统唤醒， 而watchOS不会被唤醒</p>
<h2 id="Project_Setup">Project Setup</h2><p><img src="http://chuantu.biz/t2/19/1447515689x-1566679828.png" alt=""></p>
<h2 id="Creating_the_User_Interface">Creating the User Interface</h2><h3 id="iOS_App">iOS App</h3><p><img src="http://chuantu.biz/t2/19/1447516155x1822610100.png" alt=""></p>
<h3 id="WatchApp">WatchApp</h3><p><img src="http://chuantu.biz/t2/19/1447516336x1822610092.png" alt=""></p>
<h2 id="Using_the_Watch_Connectivity_Framework">Using the Watch Connectivity Framework</h2><p>要实现数据的互传我们还需要WCSession<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="type">WKInterfaceController</span>,<span class="type">WCSessionDelegate&#123;</span></span></div><div class="line">    <span class="keyword">var</span> session : WCSession!</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用WCSession.defaultSession()可以获取到session实例，下一步我们需要设置session的delegate和激活session<br>在我们构建之前我们先要调用WCSession.isSupported()来确认当期设备是否支持WCSession，在activateSession之前我们先要设置delegate<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">willActivate</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.willActivate()</div><div class="line">    <span class="keyword">if</span> (<span class="type">WCSession</span>.isSupported()) &#123;</div><div class="line">        session = <span class="type">WCSession</span>.defaultSession()</div><div class="line">        session.delegate = <span class="keyword">self</span></div><div class="line">        session.activateSession()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在WatchApp就能收到消息了。当session激活后我们只要用sendMessage(_:replyHandler:errorHandler:)就可以发送消息了第一个参数不能为空<br>replyHandler 成功回调<br>errorHandler失败回调<br>点击send按钮，watch就会发送一条hello iPhone的消息<br>InterfaceController.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> messageToSend = [<span class="string">"Value"</span>:<span class="string">"Hello iPhone"</span>]</div><div class="line">    session.sendMessage(messageToSend, replyHandler: &#123; replyMessage <span class="keyword">in</span></div><div class="line">        <span class="comment">//handle and present the message on screen</span></div><div class="line">        <span class="keyword">let</span> value = replyMessage[<span class="string">"Value"</span>] <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">        <span class="keyword">self</span>.messageLabel.setText(value)</div><div class="line">    &#125;, errorHandler: &#123;error <span class="keyword">in</span></div><div class="line">        <span class="comment">// catch any errors here</span></div><div class="line">        <span class="built_in">print</span>(error)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了能在iOS设备上处理这个信息<br>我们需要实现session(_:didReceiveMessage:)<br>InterfaceController.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveMessage message: [String : AnyObject], replyHandler: <span class="params">([String : AnyObject])</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="comment">//handle received message</span></div><div class="line">    <span class="keyword">let</span> value = message[<span class="string">"Value"</span>] <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">    <span class="comment">//use this to present immediately on the screen</span></div><div class="line">    dispatch_async(dispatch_get_main_queue()) &#123;</div><div class="line">        <span class="keyword">self</span>.messageLabel.setText(value)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//send a reply</span></div><div class="line">    replyHandler([<span class="string">"Value"</span>:<span class="string">"Yes"</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>iOS设备的VC里面实现这段代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"><span class="keyword">import</span> WatchConnectivity</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> session: <span class="type">WCSession</span>!</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> messageLabel: <span class="type">UILabel</span>!</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> sendButton: <span class="type">UIButton</span>!</div><div class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span><span class="params">(sender: AnyObject)</span></span> &#123;</div><div class="line">        <span class="comment">//Send Message to WatchKit</span></div><div class="line">        <span class="keyword">let</span> messageToSend = [<span class="string">"Value"</span>:<span class="string">"Hi watch, can you talk to me?"</span>]</div><div class="line">        session.sendMessage(messageToSend, replyHandler: &#123; replyMessage <span class="keyword">in</span></div><div class="line">        <span class="comment">//handle the reply</span></div><div class="line">        <span class="keyword">let</span> value = replyMessage[<span class="string">"Value"</span>] <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">        <span class="comment">//use dispatch_asynch to present immediately on screen</span></div><div class="line">        dispatch_async(dispatch_get_main_queue()) &#123;</div><div class="line">            <span class="keyword">self</span>.messageLabel.text = value</div><div class="line">        &#125;</div><div class="line">        &#125;, errorHandler: &#123;error <span class="keyword">in</span></div><div class="line">        <span class="comment">// catch any errors here</span></div><div class="line">            <span class="built_in">print</span>(error)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">        <span class="keyword">if</span> (<span class="type">WCSession</span>.isSupported()) &#123;</div><div class="line">            session = <span class="type">WCSession</span>.defaultSession()</div><div class="line">            session.delegate = <span class="keyword">self</span>;</div><div class="line">            session.activateSession()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//Swift</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveMessage message: [String : AnyObject], replyHandler: <span class="params">([String : AnyObject])</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="comment">//handle received message</span></div><div class="line">        <span class="keyword">let</span> value = message[<span class="string">"Value"</span>] <span class="keyword">as</span>? <span class="type">String</span></div><div class="line">    dispatch_async(dispatch_get_main_queue()) &#123;</div><div class="line">        <span class="keyword">self</span>.messageLabel.text = value</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//send a reply</span></div><div class="line">        replyHandler([<span class="string">"Value"</span>:<span class="string">"Hello Watch"</span>])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Exploring_the_WCSessionDelegate_Protocol">Exploring the WCSessionDelegate Protocol</h2><p>我们接收消息的方法session(<em>:didReceiveMessage:)并没有:replyHandler这其实也就是说发出消息后并不需要回应<br>除了发送字典外我们还可以发送data<br>发送者调用sendMessageData(</em>:replyHandler:errorHandler:)<br>接收者以协议接收<br>session(<em>:didReceiveMessageData:)<br>session(</em>:didReceiveMessageData:replyHandler:)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Leon" />
          <p class="site-author-name" itemprop="name">Leon</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leon</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
